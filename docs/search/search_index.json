{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to CAMEO","text":"<p>CAMEO is a lightweight middleware providing services to write distributed applications running on any platform and language. CAMEO focuses on the applications which are the main components of the CAMEO middleware.</p> <p>CAMEO allows:</p> <ul> <li>Starting, stopping, synchronizing your apps wherever they run: CAMEO is a remote application manager.</li> <li>Making your apps communicate: High-level communication patterns are provided.</li> <li>Single entry point for running the entire network of apps.</li> </ul> <p>The CAMEO middleware is made up of:</p> <ul> <li>A server application configurable and running on any host.</li> <li>A console application running on any host.</li> <li>Different APIs for C++, Java, Python languages.</li> </ul> <p>CAMEO is very flexible and many different use cases are possible.  There is no constraint on the applications that can be managed by CAMEO: graphical or black box applications are supported. With CAMEO, it becomes very easy to integrate any external component including proprietary software.</p>"},{"location":"#typical-use-case","title":"Typical use case","text":"<p>Following diagram shows a typical use case:</p> <p></p> <p>Three computers A, B, C are used. A CAMEO server is running on the computers B and C. The applications App1 and App2 are installed on B and C and registered into the respective CAMEO servers. Sequence of actions:</p> <ul> <li>Execute a console to start the execution of App1 by contacting the CAMEO server on B.<ul> <li>The application App1 is starting and starts the execution of App2 by contacting the CAMEO server on C.</li> <li>App1 is waiting for the initialization of App2 and once it is done, App1 is sending requests to App2 that is responding to App1.</li> </ul> </li> <li>Use the console to stop the execution of App1.<ul> <li>App1 is stopping and stops App2.</li> </ul> </li> </ul> <p>Notice that the interaction between App1 and App2 is made using the API. This example shows that with a single entry point with the console, two apps are started, synchronized and communicate.</p> <p>Contact legoc@ill.eu for any help.</p>"},{"location":"configure-a-server/","title":"Configure a server","text":""},{"location":"configure-a-server/#the-main-configuration-file","title":"The main configuration file","text":"<p>The main configuration file of a CAMEO server is an XML file usually called config.xml but the name is not imposed. We already saw a minimal example where no application were registered. Let's discover the different options. </p> <p>Let's take an example with two applications registered: <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;config host=\"mycomputer\" port=\"7000\" proxy_ports=\"10000, 10001, 10002\"\n        polling_time=\"100\" sleep_time=\"10\"\n        max_applications=\"20\" \n        log_level=\"FINE\" log_directory=\"/home/cameo/log\"&gt;\n    &lt;applications&gt;\n        &lt;application name=\"App1\" description=\"My application\"\n                     working_directory=\"\"\n                     starting_time=\"inf\" stopping_time=\"20\" \n                     multiple=\"no\" restart=\"no\" info_arg=\"yes\"\n                     stream=\"yes\"\n                     log_directory=\"default\"\n                     environment=\"app.properties\"&gt;\n            &lt;start executable=\"/home/cameo/app1\" args=\"-option test\"/&gt;\n        &lt;/application&gt;\n        &lt;application name=\"App2\"&gt;\n            &lt;start executable=\"/home/cameo/app2\"/&gt;\n            &lt;stop executable=\"kill\" args=\"-2\"/&gt;\n            &lt;error executable=\"bash\" args=\"/home/cameo/error.sh -debug\"/&gt;\n        &lt;/application&gt;\n    &lt;applications&gt;  \n&lt;/config&gt;\n</code></pre></p> <p>The root tag is config which has the applications tag as child which has many application tags as children. Each application tag has a mandatory start child tag and optional stop and error children.</p> <p>Attributes of the config tag:</p> Attribute Default value Description host The default interface Hostname or \"IP\" or an IPv4 address or localhost to override the default interface. If \"IP\" then the IPv4 address related to localhost is provided. port 7000 The base port of the server. proxy_ports The three ports used by the proxy. The first two ports are accessible from outside, the third one is for internal use. By default, proxies are not started. polling_time 100 Sleep duration in milliseconds between some phases of the lifecycle of an app and sleep duration in the output stream retrieval of an app. sleep_time 5 Sleep duration in milliseconds between two requests process. It avoids the server to stall if there are two many pending requests. max_applications 65536 Max number of running apps at a time. log_level INFO Log level. Possible values are OFF, INFO, FINE, FINER, FINEST. log_directory . The directory where the file cameo.log is written. <p>Attributes of the application tag:</p> Attribute Default value Description name The name of the app, given when a start is requested. This is a mandatory attribute. description The description of the app. working_directory . The directory where the app is executed. starting_time 0 The duration in seconds after which the app becomes RUNNING. Possible value is a positive integer or inf for infinity. stopping_time 10 The duration in seconds after which the app is killed when a stop is requested. Possible value is a positive integer or inf for infinity. multiple inf If no, then only one instance is accepted. If yes or inf, there is no limit on the number of parallel instances. A number indicates the maximum of parallel instances. Possible values are yes, no, inf or a strictly positive number. restart no If yes, the app is automatically restarted when it died unexpectedly. Possible values are yes and no. info_arg yes If yes, an additional argument containing information about the app is passed. For unmanaged application, it can be necessary to set it to no. Possible values are yes and no. stream yes If yes, the standard error and output stream are published to the console application and other instance reference objects. Possible values are yes and no. log_directory The directory where the &lt;name&gt;.&lt;id&gt;.log file of the app instance is written. An empty value means no log, a default value means it inherits the value of the config tag. environment The environment file where environment variables dedicated to the app can be defined. <p>Attributes of the start, stop, error tags:</p> Attribute Default value Description executable The path to the program executed. args The arguments passed to the executable. <p>The start tag is mandatory, the associated executable program is executed when a start is requested. The arguments args are first set then come the arguments passed to the start request and then the last argument is added if info_arg is yes. </p> <p>When the stop tag is defined, a stop command is executed corresponding to the executable with the arguments args. It can be useful for programs that can be stopped nicely with a signal. However for managed CAMEO apps, it is better to define a stop handler that is automatically triggered when a stop is requested.</p> <p>When the error tag is defined, an error command is executed when the application finishes with an error. That can be a segmentation fault for a C++ program or an exception for a Java program. In that case, the error can be processed e.g. analyze the generated core to send an email.</p>"},{"location":"configure-a-server/#environment-files","title":"Environment files","text":"<p>An application often depends on environment variables. When an application is launched on a local account, some specific environment variables may have been defined. However when the application is launched by a CAMEO server, it may not work, because some environment variables are missing. Indeed the environment is not the one of the local account even if the CAMEO server is launched as a user service. The environment files are there to solve this problem.</p> <p>An example with the app.properties file: <pre><code>MYAPP_HOME=/home/cameo/myapp\nLD_LIBRARY_PATH=/usr/local/lib\nPATH=/home/cameo/bin:$PATH\n</code></pre></p> <p>The variables are written using a standard shell syntax, and composition is possible. These variables are applied to the context of the launched process. So be careful with the special PATH variable: it cannot be the path of the executable. However if you need to execute a program inside your app, then this PATH will be used. Be also careful with LD_LIBRARY_PATH which is for security reason not inherited. It means that it is empty by default.</p> <p>If your app has a graphical user interface, you may need to check the variable DISPLAY and add it to the environment file if necessary.</p> <p>One practical way to check the required environment variables is to launch the app in a working environment e.g. on a local account and print the list of environment variables.</p>"},{"location":"configure-a-server/#log","title":"Log","text":"<p>The CAMEO server application is logging in the cameo.log file and it is also possible to log the standard error and output of the applications started by the CAMEO server.</p> <p>Indeed when you need to debug an application, the standard error and output may be useful.  CAMEO applications are started in background and it is possible to log the standard error and output. For that, you need to define the log_directory attribute of the application tag with a path that exists or the default value which is the location of the cameo.log file. Each running CAMEO application has a unique id provided by the server and the produced log file is &lt;name&gt;.&lt;id&gt;.log for an app with the name name and id id. For instance it could be App2.12.log.</p>"},{"location":"configure-a-server/#start-the-server","title":"Start the server","text":"<p>Once the configuration file and its associated environment files have been defined, the CAMEO server can be started. The server can be started directly in a shell however it is recommended to start it as a service. See the Installation page for more details.</p>"},{"location":"configure-a-server/#registered-and-unregistered-apps","title":"Registered and unregistered apps","text":"<p>CAMEO is very flexible and accepts different combinations for an application to be controlled by CAMEO.</p>"},{"location":"configure-a-server/#this-initialized-with-the-arguments-variable","title":"This initialized with the arguments variable","text":"<p>Usually to benefit from the CAMEO services inside an application, the This object is initialized by passing the arguments of the program. In C++: <pre><code>int main(int argc, char *argv[]) {\n\n    // Initialize This.\n    cameo::This::init(argc, argv);\n</code></pre></p> <p>In Java: <pre><code>import eu.ill.cameo.base.This;\n\npublic static void main(String[] args) {\n\n    // Initialize This.\n    This.init(args);\n</code></pre></p> <p>In Python: <pre><code>import sys\nimport cameopy\n\n## Initialize This.\ncameopy.This.init(sys.argv)\n</code></pre></p> <p>Once This is initialized it can be used for example to get a reference to the CAMEO server that started it. When This is initialized with the arguments variable, there are two cases:</p> <ul> <li>Registered application: If the application is registered in the configuration file, then info_arg must be yes which is the default value so it is not necessary to specify it. Otherwise the application will not start.</li> <li>Not registered application: If the application is not registered in the configuration file, it is possible to start directly the app by adding a last argument that contains the CAMEO server reference and its name. For instance: <pre><code>/home/cameo/app1 \"{\\\"name\\\":\\\"App1\\\", \\\"server\\\":\\\"tcp://localhost:10000\\\"}\"\n</code></pre> Then if the passed arguments are correct, This will initialize and the application will become attached to the CAMEO server referenced by the endpoint in the server value.</li> </ul>"},{"location":"configure-a-server/#this-initialized-with-explicit-arguments","title":"This initialized with explicit arguments","text":"<p>It is not mandatory to initialize This with the program arguments. It is possible to pass an explicit endpoint that must be a local endpoint because it has no sense to attach the app to a remote computer. In C++: <pre><code>cameo::This::init(\"App1\", \"tcp://localhost:10000\");\n</code></pre> In Java: <pre><code>This.init(\"App1\", \"tcp://localhost:10000\");\n</code></pre> In Python: <pre><code>cameopy.This.init(\"App1\", \"tcp://localhost:10000\")\n</code></pre> In that case, the application shall not be registered.</p>"},{"location":"configure-a-server/#this-not-initialized","title":"This not initialized","text":"<p>If you have a black box application i.e. that you cannot compile or modify, then you cannot initialize This inside but you can still register the application in the configuration file. However it is recommended in that special case to set info_arg to no. Otherwise the additional argument may not be supported by the app when it parses the arguments.</p>"},{"location":"configure-a-server/#registered-vs-unregistered","title":"Registered vs unregistered","text":"<p>We saw the different cases based on the initialization of This or not. But what is the difference between a registered app and an unregistered app that is attached?  </p> <p>The response is simple: a registered app can be started by the console cmo from another computer. Moreover in case of unexpected termination a program can be run to make a report.  </p> <p>Registering an app offers more flexibility in the way to start an app.</p>"},{"location":"configure-a-server/#register-a-script","title":"Register a script","text":"<p>If you want to register a script e.g. a Bash script or a Python script, it is highly recommended to define the executable with the interpreter program rather the script itself even if it is executable. For example: <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;config host=\"mycomputer\"&gt;\n    &lt;applications&gt;\n        &lt;application name=\"Script1\"&gt;\n            &lt;start executable=\"/usr/bin/bash\" args=\"/home/cameo/app1.sh\"/&gt;\n        &lt;/application&gt;\n        &lt;application name=\"Script2\"&gt;\n            &lt;start executable=\"/usr/bin/python3\" args=\"-u /home/cameo/app2.py\"/&gt;\n        &lt;/application&gt;\n    &lt;applications&gt;  \n&lt;/config&gt;\n</code></pre> The reason is because the underlying process execution works not well when the executable is the script.</p>"},{"location":"configure-a-server/#ports","title":"Ports","text":"<p>The implementation of a CAMEO server is based on ZeroMQ and a sockets of different types are open. Here are the different ports:</p> <ul> <li>Base: This is the port of the server endpoint. By default it is 7000 but it can be defined by the port attribute in the configuration file.</li> <li>Status: This is the port from which are published the events of status of the different running applications.</li> <li>Stream: Each application for which the attribute stream is set to yes publishes the standard error and output on a stream port.</li> <li>Coms: We will see later that the provided coms also use some ports for their implementation.</li> <li>Proxy: The ports used by the proxies. See section Use the proxies with a firewall for more details.</li> </ul> <p>Except the base port and the proxy ports that are fixed meaning that they must be free before starting the CAMEO server, all the other ports are dynamically assigned i.e. they will surely assigned.</p>"},{"location":"configure-a-server/#stop-and-error-executables","title":"Stop and error executables","text":"<p>If you need to define a stop executable then you can send a signal to the process of the application. For instance: <pre><code>&lt;stop executable=\"kill\" args=\"-2\"/&gt;\n</code></pre> The PID of the running application is added as a last argument.</p> <p>If you need to define an error executable, you can for instance define: <pre><code>&lt;error executable=\"bash\" args=\"/home/cameo/error.sh -debug\"/&gt;\n</code></pre> If the running application terminates with an error the following arguments will be added to the command executed: id, error code, state before the error. For instance: <pre><code>bash /home/cameo/error.sh -debug 13 139 RUNNING\n</code></pre> These information can be used to send a report by email.</p>"},{"location":"control-the-apps/","title":"Control the apps","text":"<p>The first goal of CAMEO is to provide services for starting, stopping, synchronizing remote applications. The control of the lifecycle of the applications is made either by the console i.e. cmo either programmatically using the API. Here are the controls:</p> <ul> <li>Start: Starts a remote application that will run on the contacted CAMEO server. The application must be registered.</li> <li>Stop: Stops a running remote application. The application is notified and can properly stop.</li> <li>Kill: Kills a running remote application. The application is immediately terminated.</li> <li>Connect: Connects a running application. The combination of these controls gives lots of flexibility e.g. applications can be started in cascade.</li> </ul>"},{"location":"control-the-apps/#state-diagram-of-an-app","title":"State diagram of an app","text":"<p>Every control is made by contacting the CAMEO server which is responsible to control the applications. Every CAMEO application has a sequence of states. The following diagram shows the complete possibilities:</p> <p></p> <p>The arrows show which transitions are possible.  </p> <p>The different states are described:</p> <ul> <li>Starting: Once the CAMEO server received a start request for a valid application.</li> <li>Running: The application becomes Running after a defined amount of time or the application defined itself as running.</li> <li>Success: The application successfully terminated without any stop or kill request.</li> <li>Stopping: Once the CAMEO server received a stop request for a running application.</li> <li>Stopped: The application successfully terminated after a stop request.</li> <li>Killing: Once the CAMEO server received a kill request for a running application.</li> <li>Killed: The application successfully terminated after a kill request.</li> <li>Processing Failure: Once the application encountered an internal error and terminated. An error process specific to the application is called.</li> <li>Failure: The error process has terminated.</li> </ul> <p>Once the CAMEO server is changing the state of an application, it also publishes the new state as an event. All the connected clients receive the new state and can react to it.</p>"},{"location":"control-the-apps/#events-in-the-api-and-the-console","title":"Events in the API and the console","text":"<p>Let's take a concrete example and show how to do it with the API and the console. Here is the diagram showing the interactions: </p> <p></p> <p>Sequence of actions:</p> <ul> <li>The application App1 on A is contacting the CAMEO server on B to start App2.</li> <li>The application App2 is running on B.</li> <li>The application App3 on C is contacting the CAMEO server on B to connect App2.</li> <li>The console on D is contacting the CAMEO server on B to connect App2.</li> <li>The application App3 on C stops App2.</li> <li>The application App1 and console are notified that App2 stopped.</li> </ul> <p>Let's see the code for each application. The application App2 written in Java can look like:</p> <pre><code>import eu.ill.cameo.base.This;\n\npublic class JavaApp {\n\n    public static void main(String[] args) {\n\n        // Initialize the CAMEO application represented by This.    \n        This.init(args);\n\n        // Infinite printing loop.\n        int i = 0;\n        while (true) {\n            System.out.println(\"Printing \" + i);\n            try {\n                Thread.sleep(100);\n            }\n            catch (InterruptedException e) {\n            }\n            i++;\n        }\n\n        This.terminate();   \n    }\n}\n</code></pre> <p>It simply prints a new line every 100 ms infinitely. Notice that the name \"App2\" is the name of the application registered in the CAMEO server so that there is no link with the class name. Moreover consider that the app is registered so that its standard output and error are streamed.</p> <p>The application App1 written in C++ has the following lines:</p> <pre><code>#include &lt;cameo/api/cameo.h&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char *argv[]) {\n\n    // Define the reference to the CAMEO server in B.   \n    std::unique_ptr&lt;cameo::Server&gt; server = cameo::Server::create(\"tcp://B:7000\");\n\n    // Initialize the server.\n    server-&gt;init();\n\n    // Start the application \"App2\" and obtain a reference to the running app.\n    std::unique_ptr&lt;cameo::App&gt; app2 = server.start(\"App2\");\n\n    // Wait for the end of the app and get the terminal state.\n    cameo::state::Value state = app2-&gt;waitFor();\n\n    // Print the terminal state.\n    std::cout &lt;&lt; \"The application \" &lt;&lt; *app2 \n              &lt;&lt; \" terminated with state \" &lt;&lt; cameo::toString(state) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>It simply contacts the CAMEO server in B and starts App2 then waits for its termination.</p> <p>The application App3 written in Python has the following lines:</p> <pre><code>import cameopy\n\n# Define the reference to the CAMEO server in B.\nserver = cameopy.Server.create(\"tcp://B:7000\")\n\n# Initialize the server.\nserver.init()\n\n# Connect the application \"App2\" that is supposed running.\napp2 = server.connect(\"App2\")\n\n# Stop the app.\napp2.stop()\n\n# Wait for the end of the app and get the terminal state.\nstate = app.waitFor()\n\nprint(\"The application\", app2.toString(), \"terminated with state\", cameopy.toString(state))\n</code></pre> <p>On computer D, the console connects to App2 and receives some output before App2 is stopped:</p> <pre><code>cmo -e tcp://B:7000 connect App2 \nConnected App2.5\nPrinting 5\nPrinting 6\nPrinting 7\nPrinting 8\nThe application App2.5 terminated successfully.\n</code></pre> <p>The lines starting with Connected and The application are written by the console whereas the lines starting with Printing come from the app itself as it was configured to stream its error and output.</p> <p>The calls to waitFor() were blocking and the termination of App2 unblocked them as an event was sent from the CAMEO server to all the clients. The console received the error and output stream before stopping, the connect command being blocking.</p>"},{"location":"control-the-apps/#using-the-console","title":"Using the console","text":"<p>The console cmo offers interesting features to start or monitor a CAMEO environment. To print the help: <pre><code>cmo\n</code></pre></p> <p>To display the list of registered apps that can be started: <pre><code>cmo list\n</code></pre></p> <p>By default, the CAMEO server is the local on the 7000 port but it can be configured. If a CAMEO server is running on the port 8000: <pre><code>cmo -p 8000 list\n</code></pre></p> <p>If a CAMEO server is running on B: <pre><code>cmo -e tcp://B:7000 list\n</code></pre></p> <p>To start App2 from localhost: <pre><code>cmo start App2\n</code></pre></p> <p>The command immediately returns. Then it is possible to see if it is running: <pre><code>cmo apps\nName ID        PID       Status              Args\n-------------------------------------------------\nApp2 5         9087      RUNNING\n</code></pre></p> <p>The ID is the id of the CAMEO server which is unique different from the PID which is the common system process id.</p> <p>We can connect to it now: <pre><code>cmo connect App2\nPrinting 8\nPrinting 9\nPrinting 10\nQ\n</code></pre> The command is blocking and typing ctl+c or shift+q stops the command but not the app.</p> <p>To stop App2: <pre><code>cmo stop App2\n</code></pre></p> <p>As there is no stop handler defined for App2, the stop is equivalent to a kill, so we could have done: <pre><code>cmo kill App2\n</code></pre></p> <p>To start App2 with a blocking command, we can use: <pre><code>cmo exec App2\nPrinting 1\nPrinting 2\nPrinting 3\nPrinting 4\n^CKilled App2.6.\n</code></pre> This time we typed ctl+c to kill the app. We could have used shift+s to cleanly stop the app or shift+q to exit the console without stopping the app which would still run in background.</p> <p>Some additional commands and features can be interesting to know. </p> <p>We saw that by default cmo contacts the local CAMEO server on port 7000. You can change that by defining the CAMEO_SERVER environment variable e.g. with tcp://localhost:8000 which can be useful if you configured the CAMEO server with that port.</p> <p>You can display the CAMEO server endpoint: <pre><code>cmo endpoint\n</code></pre> You can display the version of the server: <pre><code>cmo version\n</code></pre></p>"},{"location":"control-the-apps/#pass-arguments","title":"Pass arguments","text":"<p>It is possible to pass arguments to a start request. With the console it is naturally done: <pre><code>cmo start App2 -debug true -timeout 10\n</code></pre> This example shows that the arguments -debug true -timeout 10 will be passed to the executable. It can also be done with the APIs. In C++: <pre><code>server.start(\"App2\", {\"-debug\", \"true\", \"-timeout\", \"10\"});\n</code></pre> In Java: <pre><code>server.start(\"App2\", new String[]{\"-debug\", \"true\", \"-timeout\", \"10\"});\n</code></pre> In Python: <pre><code>server.start(\"App2\", [\"-debug\", \"true\", \"-timeout\", \"10\"]);\n</code></pre> These arguments are set after the arguments defined into the configuration file.</p>"},{"location":"control-the-apps/#application-state","title":"Application state","text":"<p>There are different ways to get the state of an app. We already saw that waitFor() returns a state which is the last state of the app execution. You can also get the states directly:</p> <p>For example in C++: <pre><code>// Get the last execution state.\ncameo::state::Value state = app-&gt;getLastState();\n\n// Get the actual state that can be NIL if the app is not executing anymore.\ncameo::state::Value state = app-&gt;getActualState();\n\n// Get the past execution states, e.g. from RUNNING to SUCCESS.\nstd::set&lt;cameo::state::Value&gt; states = app-&gt;getPastStates();\n</code></pre></p> <p>The call to getLastState() does not invoke a call on the CAMEO server but only pulls all the states already received. If the app has terminated then it should be SUCCESS, STOPPED, KILLED or FAILURE. However a call to getActualState() makes a request to the CAMEO server i.e. it can fail if the server is not accessible anymore.</p>"},{"location":"control-the-apps/#exit-code","title":"Exit code","text":"<p>Sometimes we need to get the exit code of an app. It is possible to do it with the API as well as with the console. The APIs provide the getExitCode() function or method of the Instance class.  We suppose to have an App4 application that returns after a certain amount of time.</p> <p>For example in C++: <pre><code>// Connect the application \"App4\" and obtain a reference to the running app.\nstd::unique_ptr&lt;cameo::App&gt; app4 = server.connect(\"App4\");\n\n// Wait for the end of the app and get the terminal state.\ncameo::state::Value state = app4-&gt;waitFor();\n\n// Get the exit code.\nint exitCode = app4-&gt;getExitCode();\n</code></pre></p> <p>To get the value of the exit code of the app with the console depends on the shell you use. With a bash shell: <pre><code>cmo exec App4\nThe application App4.13 terminated successfully.\nexitCode=$?\n</code></pre></p> <p>What you do with this code is on your own.</p>"},{"location":"control-the-apps/#stop-handler","title":"Stop handler","text":"<p>We saw before that there was a difference between a stop and a kill request. The CAMEO server immediately stops the app for a kill request whereas in case of a stop request it sets the state STOPPING to the app. The app receives the STOPPING event and a stop handler is triggered if it has been registered allowing to properly terminate the app.</p> <p>The C++, Java and Python APIs support the stop handler. An example in C++: <pre><code>#include &lt;cameo/api/cameo.h&gt;\n#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char *argv[]) {\n\n    // Init the app.\n    cameo::This::init(argc, argv);\n\n    // Shared variable.\n    std::atomic_bool stopping(false);\n\n    // Define a stop handler.\n    cameo::application::This::handleStop([&amp;] {\n        std::cout &lt;&lt; \"Stop handler executed\" &lt;&lt; std::endl;\n        stopping.store(true);\n    });\n\n    // Loop until stop is triggered.\n    while (!stopping.load()) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n\n    return 0;\n}\n</code></pre></p> <p>This example uses an std::atomic_bool variable to stop the while loop.</p> <p>An example in Java: <pre><code>import eu.ill.cameo.base.This;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class JavaStop {\n\n    // Shared variable.\n    public static AtomicBoolean stopping = new AtomicBoolean(false);\n\n    public static void main(String[] args) {\n\n        // Init the app.\n        This.init(args);\n\n        // Define a stop handler.\n        This.handleStop(() -&gt; {\n            System.out.println(\"Stop handler executed\");\n            stopping.set(true);\n        });\n\n        // Loop until stop is triggered.        \n        while (!stopping.get()) {\n            try {\n                Thread.sleep(100);\n            }\n            catch (InterruptedException e) {\n            }\n        }\n\n        This.terminate();           \n    }\n}\n</code></pre></p> <p>This example also uses an AtomicBoolean variable to stop the while loop.</p> <p>An example in Python: <pre><code>import cameopy\nimport sys\nimport time\nfrom threading import Event\n\n# Init the app.\ncameopy.This.init(sys.argv)\n\n# Shared variable.\nstopping = Event()\n\n# Define the stop handler.\ndef stop():\n    print(\"Stop handler executed\")\n    stopping.set()\n\n# Register the handler.\ncameopy.This.handleStop(stop)\n\n# Loop until stop is triggered.\nwhile not stopping.is_set():\n    time.sleep(0.1)\n</code></pre></p> <p>The Python example follows the same principle as the C++ and Java examples but this time we use the Event object provided by the threading module to share the stopping state.</p> <p>To finish, it is highly recommended to follow these guidelines to implement a stop handler:</p> <ul> <li>Do not implement cleaning code e.g. resource deallocation in stop handlers.</li> <li>Only write code that unblocks blocking calls: graphical loop, etc.</li> <li>Let the cleaning code at the very end of the main.</li> </ul>"},{"location":"control-the-apps/#connect-to-the-starter-app","title":"Connect to the starter app","text":"<p>There are some use cases where it is interesting or even necessary to get a reference to the application that started this application. Let's take the previous example where we defined the code of App2. We modify it to get an access to the starter app: <pre><code>import eu.ill.cameo.base.This;\n\npublic class JavaApp {\n\n    public static void main(String[] args) {\n\n        // Initialize the CAMEO application represented by This.    \n        This.init(args);\n\n        // Get the starter app.\n        ServerAndApp starter = This.connectToStarter();\n\n        // Infinite printing loop.\n        int i = 0;\n        while (true) {\n            System.out.println(\"Printing \" + i);\n            try {\n                Thread.sleep(100);\n            }\n            catch (InterruptedException e) {\n            }\n            i++;\n        }\n        starter.terminate();\n        This.terminate();   \n    }\n}\n</code></pre></p> <p>In our example, the starter app should be the running application App1. But be careful, the application could have terminated since it sent the request to start App2. In C++ and Python, the function is also connectToStarter() member of the This object.</p> <p>Once you have a reference to the starter you can decide to stop it or use it to connect a communication object.</p>"},{"location":"control-the-apps/#standard-error-and-output","title":"Standard error and output","text":"<p>The standard error and output can be printed by the console application or retrieved by the API. For that the attribute stream of the application tag must have been set to yes in the configuration of the application. See the page Configure a server. An example with the C++ API: <pre><code>// Start the app with the OUTPUTSTREAM option.\nstd::unique_ptr&lt;cameo::App&gt; app = server.start(\"App2\", cameo::option::OUTPUTSTREAM);\n\n// Get the outputstream socket.\nstd::shared_ptr&lt;cameo::OutputStreamSocket&gt; socket = app-&gt;getOutputStreamSocket();\n\n// Define a thread to retrieve the output.\nstd::thread outputThread([&amp;] {\n    while (true) {\n        std::optional&lt;Output&gt; output = socket-&gt;receive();\n        if (output) {\n            std::cout &lt;&lt; output.value().getMessage() &lt;&lt; std::endl;\n        }\n        else {\n            // The socket has terminated normally or was canceled.\n            return;\n        }\n    }\n});\n\n// Wait for 1s.\nstd::this_thread::sleep_for(std::chrono::seconds(1));\n\n// Stop the output stream socket.\nsocket-&gt;cancel();\n\n// Wait for the end of the thread.\noutputThread.join();\n</code></pre></p> <p>Starting the application with the option OUTPUTSTREAM creates an output stream socket so that all the stream can be retrieved.</p> <p>Same example in Java: <pre><code>// Start the app with the OUTPUTSTREAM option.\nApp app = server.start(\"App2\", Option.OUTPUTSTREAM);\n\n// Get the outputstream socket.\nOutputStreamSocket socket = app.getOutputStreamSocket();\n\n// Define a thread to retrieve the output.\nThread outputThread = new Thread(() -&gt; {\n    while (true) {\n        Output output = socket.receive();\n        if (output != null) {\n            System.out.println(output.getMessage());\n        }\n        else {\n            // The socket has terminated normally or was canceled.\n            return;\n        }\n    }\n}); \noutputThread.start();\n\n// Wait for 1s.\ntry {\n    Thread.sleep(1000);\n\n    // Stop the output stream socket.\n    socket.cancel();\n\n    // Wait for the end of the thread.\n    outputThread.join();\n\n}\ncatch (InterruptedException e) {\n}\n</code></pre></p> <p>And the Python example: <pre><code>import threading\n\n# Define the function retrieving the output.\ndef printOutput(socket):\n    while True:\n        output = socket.receive()\n        if output:\n            print(output.getMessage())\n        else:\n            # The socket has terminated normally or was canceled.\n            return\n\n# Start the app with the OUTPUTSTREAM option.\napp = server.start(\"streampy\", cameopy.option.OUTPUTSTREAM)\n\n# Get the outputstream socket.\nsocket = app.getOutputStreamSocket()    \n\n# Start the thread.\nt = threading.Thread(target=printOutput, args=(socket,))\nt.start()\n\n# Wait for 1s.\ntime.sleep(1)\n\n# Stop the output stream socket.\nsocket.cancel()\n\n# Wait for the end of the thread.\nt.join()\n</code></pre></p> <p>Retrieving the output may not be only restricted to debug. If you need to integrate an external program that only has output, control could be done by analyzing the output stream.</p>"},{"location":"control-the-apps/#unlinked-apps","title":"Unlinked apps","text":"<p>By default, if App1 starts App2 and App1 finished before App2 then App2 will be stopped i.e. a stop request will be sent to its CAMEO server. This default behaviour avoids to have orphaned apps that have in fact no reason to live especially if their starter app terminated unexpectedly.</p> <p>However there are some cases where it is interesting to detach the lifecycle of an app from its starter. In that case, you simply have to specify it in the start command.</p> <p>In C++: <pre><code>std::unique_ptr&lt;cameo::App&gt; app2 = server.start(\"App2\", cameo::UNLINKED);\n</code></pre></p> <p>In Java: <pre><code>App instance = server.start(\"App2\", Option.UNLINKED);\n</code></pre></p>"},{"location":"dependencies/","title":"Dependencies","text":""},{"location":"dependencies/#jzmq-or-jeromq","title":"JZMQ or JeroMQ?","text":"<p>CAMEO provides three Java projects and a C++ project. ZeroMQ is written in C and using it in Java projects can be done:</p> <ul> <li>Use the Java binding JZMQ.</li> <li>Use the pure Java implementation JeroMQ.</li> </ul> <p>CAMEO can use both as they follow the same interface, so that they can be easily replaced. However some differences exist:</p> <ul> <li>JZMQ has better performances than JeroMQ.</li> <li>JZMQ is more difficult to configure as the dynamic library of ZeroMQ must be accessible.</li> <li>JZMQ is no longer developped. It is thus preferrable to use JeroMQ if no blockings are encountered.</li> </ul>"},{"location":"dependencies/#jzmq-compilation","title":"JZMQ compilation","text":"<p>JeroMQ does not require any compilation because the jar is downloaded from a Maven repository. However if the JZMQ Java jar is downloaded from a Maven repository, the C dynamic library must be compiled if not accessible from a package.</p> <ul> <li>On Debian, we use the package libzmq-jni.</li> <li>On Windows 7 64bits, we compiled JZMQ using Visual Studio 2015 as explained in this page but we needed to add the configuration x64 for the project JZMQ.</li> </ul>"},{"location":"dependencies/#json-libraries","title":"JSON libraries","text":"<p>In the Java API, we currently use json-simple that is very simple but performant. Other libraries are less performant so that we decided to keep it.</p>"},{"location":"developments/","title":"Developments","text":"<p>Some pages about the development:</p> <ul> <li>Tests</li> <li>Versions and releases</li> <li>Dependencies</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>The source package comes up with examples in the different languages. The current page is showing how to run them in Linux. The end of the page shows rapidly how to run on Windows.</p>"},{"location":"examples/#setup","title":"Setup","text":""},{"location":"examples/#linux","title":"Linux","text":"<p>The Java, C++ and Python examples can be run using either jzmq or jeromq.</p> <p>Open a shell and go to the CAMEO root directory.</p> <p>Set the PATH variable so that the C++ programs are found: <pre><code>export PATH=build/examples/cpp:build/cpp/proxy:$PATH\n</code></pre></p> <p>If necessary, set the PYTHONPATH variable so that the cameopy module is found e.g.: <pre><code>export PYTHONPATH=/path/to/install/lib/python3/dist-packages:$PYTHONPATH\n</code></pre> You may have to verify that python is defined (install python-is-python3 package on Ubuntu).</p> <p>Select jzmq or jeromq Java library.</p> <p>Case jzmq: <pre><code>export CLASSPATH=examples/java/jzmq/target/cameo-examples-jzmq-full.jar\n</code></pre></p> <p>You shall define the variable LD_LIBRARY_PATH so that libjzmq.so is found: <pre><code>export LD_LIBRARY_PATH=/path/to/libjzmq\n</code></pre> Start the cameo server with the examples configuration: <pre><code>java eu.ill.cameo.server.Server examples/config.xml --log-console\n</code></pre></p> <p>In each new shell, create the alias for cmo: <pre><code>alias cmo=\"java -jar java/console/jzmq/target/cameo-console-jzmq-3.0.0-full.jar\"\n</code></pre></p> <p>Case jeromq: <pre><code>export CLASSPATH=examples/java/jeromq/target/cameo-tests-jeromq-full.jar\n</code></pre></p> <p>In each new shell, create the alias for cmo: <pre><code>alias cmo=\"java -jar java/console/jeromq/target/cameo-console-3.0.0-full.jar\"\n</code></pre></p>"},{"location":"examples/#windows","title":"Windows","text":"<p>Open a standard prompt and go to the CAMEO root directory. Then set the PATH: <pre><code>set PATH=build\\examples\\cpp\\Release;build\\cpp\\proxy\\Release;%PATH%\n</code></pre></p> <p>Set the CLASSPATH to use jeromq: <pre><code>set CLASSPATH=tests\\java\\jeromq\\target\\cameo-tests-jeromq-full.jar\n</code></pre></p> <p>If necessary, set the PYTHONPATH variable so that the cameopy module is found e.g.: <pre><code>set PYTHONPATH=build\\python\\api\\Release;%PYTHONPATH%\n</code></pre></p> <p>Run the server: <pre><code>java eu.ill.cameo.server.Server examples\\config.xml --log-console\n</code></pre></p> <p>In each new prompt or shell, create the alias for cmo: <pre><code>doskey cmo=java -jar java\\console\\jeromq\\target\\cameo-console-jeromq-3.0.0-full.jar $*\n</code></pre></p>"},{"location":"examples/#requesterresponder","title":"Requester/Responder","text":""},{"location":"examples/#java","title":"Java","text":"<p>The requester/responder in Java can be tested.</p> <p>Start the responder app in a new shell: <pre><code>cmo -p 11000 exec responder-java\n</code></pre> Execute the requester app in a new shell: <pre><code>cmo -p 11000 exec requester-java tcp://localhost:11000 java \"a message\" 10\n</code></pre> The requester app is sending 10 requests to the responder, receives the responses and then stops. Notice that the responder app also stops. Indeed the requester app stops itself the responder app.</p> <p>Now relaunch the requester app without relaunching the responder app. The requester app is also sending and receiving messages from the responder app. Indeed the responder app has been started by the requester app because it was not running.</p> <p>This example shows that by a single entry point (the console), the requester and responder apps start and communicate without losing any request and terminate synchronously.</p> <p>Code is available:</p> <ul> <li>Java Responder</li> <li>Java Requester</li> </ul>"},{"location":"examples/#c","title":"C++","text":"<p>The requester/responder in C++ can be tested in the same way by replacing java with cpp. Start the responder in a shell: <pre><code>cmo -p 11000 exec responder-cpp\n</code></pre> Execute the requester app in a new shell: <pre><code>cmo -p 11000 exec requester-cpp tcp://localhost:11000 cpp \"a message\" 10\n</code></pre> Same comments as for Java.</p> <p>Code is available:</p> <ul> <li>C++ Responder</li> <li>C++ Requester</li> </ul>"},{"location":"examples/#python","title":"Python","text":"<p>The requester/responder in Python can be tested in the same way by replacing cpp with python. Start the responder in a shell: <pre><code>cmo -p 11000 exec responder-python\n</code></pre> Execute the requester app in a new shell: <pre><code>cmo -p 11000 exec requester-python tcp://localhost:11000 python \"a message\" 10\n</code></pre> Same comments as for Java.</p> <p>Code is available:</p> <ul> <li>Python Responder</li> <li>Python Requester</li> </ul>"},{"location":"examples/#mixing-languages","title":"Mixing languages","text":"<p>You can mix the languages e.g. cpp with python: <pre><code>cmo -p 11000 exec requester-python tcp://localhost:11000 cpp \"a message\" 10\n</code></pre></p>"},{"location":"examples/#remote-execution","title":"Remote execution","text":"<p>You can also execute the last example in three different computers:</p> <pre><code>cmo -e tcp://computer-a:11000 exec requester-python tcp://computer-b:11000 cpp \"a message\" 10\n</code></pre> <p>The console cmo application is executing requester-python on computer-a which interacts with responder-cpp executing on computer-b.</p> <p>Here again, this example shows that by a single entry point (the console), the requester and responder apps start and communicate on two computers without losing any request and terminate synchronously.</p>"},{"location":"examples/#publishersubscriber","title":"Publisher/Subscriber","text":""},{"location":"examples/#java_1","title":"Java","text":"<p>The publisher/subscriber in Java can be tested. Start the publisher app in a new shell: <pre><code>cmo -p 11000 exec publisher-java\n</code></pre> Execute the subscriber app in a new shell: <pre><code>cmo -p 11000 exec subscriber-java tcp://localhost:11000 java\n</code></pre></p> <p>The publisher app is waiting for 1 subscriber before starting to send messages. The subscriber app connects to the publisher app which triggers the sending of the messages. The subscriber app is killed with ctl-c but the publisher app is still running so that you have to kill it also with ctl-c.</p> <p>Now relaunch the subscriber app without relaunching the publisher app. The publisher is started in background and the messages are sent from the publisher to the requester. If you kill the subscriber app with ctl-c then the publisher is also killed. That is because the publisher app is linked to its starter. You can also properly stop the subscriber app. To do it type shift+s in the console and press enter. In that case the subscriber app is stopping the publisher app which terminates properly.</p> <p>This example shows that by a single entry point (the console), the subscriber and publisher apps start and communicate without losing any message and terminate synchronously.</p> <p>Code is available:</p> <ul> <li>Java Publisher</li> <li>Java Subscriber</li> </ul>"},{"location":"examples/#c_1","title":"C++","text":"<p>The publisher/subscriber in C++ can be tested in the same way by replacing java with cpp. Start the publisher in a shell: <pre><code>cmo -p 11000 exec publisher-cpp\n</code></pre> Execute the subscriber app in a new shell: <pre><code>cmo -p 11000 exec subscriber-cpp tcp://localhost:11000 cpp\n</code></pre> Same comments as for Java.</p> <p>Code is available:</p> <ul> <li>C++ Publisher</li> <li>C++ Subscriber</li> </ul>"},{"location":"examples/#python_1","title":"Python","text":"<p>The publisher/subscriber in Python can be tested in the same way by replacing java with python. Start the publisher in a shell: <pre><code>cmo -p 11000 exec publisher-python\n</code></pre> Execute the subscriber app in a new shell: <pre><code>cmo -p 11000 exec subscriber-python tcp://localhost:11000 python\n</code></pre> Same comments as for Java.</p> <p>Code is available:</p> <ul> <li>Python Publisher</li> <li>Python Subscriber</li> </ul>"},{"location":"examples/#mixing-languages_1","title":"Mixing languages","text":"<p>You can mix the langagues e.g. cpp with python: <pre><code>cmo -p 11000 exec subscriber-python tcp://localhost:11000 cpp\n</code></pre></p>"},{"location":"examples/#remote-execution_1","title":"Remote execution","text":"<p>You can also execute the last example in three different computers:</p> <pre><code>cmo -e tcp://computer-a:11000 exec subscriber-python tcp://computer-b:11000 cpp\n</code></pre> <p>The console cmo application is executing subscriber-python on computer-a which interacts with publisher-cpp executing on computer-b.</p> <p>Here again, this example shows that by a single entry point (the console), the subscriber and publisher apps start and communicate on two computers without losing any request and terminate synchronously.</p>"},{"location":"exceptions/","title":"Exceptions","text":"<p>A summary of the exceptions that can be thrown in a program using the CAMEO API:</p>"},{"location":"exceptions/#list-of-exceptions","title":"List of exceptions","text":"Exception Where Description ConnectionTimeout Server.init(), Requester.init(), Subscriber.init(), all functions or methods accessing a remote Server A timeout occurs in a connection. InitException Server.init(), Responder.init(), ResponderRouter.init(), Requester.init(), Publisher.init(), Subscriber.init() Cannot initialize the object. SynchronizationTimeout Requester.init(), Subscriber.init() Timeout occurs during the synchronization of objects. InvalidArgumentException Server.init() Bad endpoint value. StartException Server.start() The application cannot be started. UnregisteredApplicationException This.init() Maximum number of running apps reached. KeyAlreadyExistsException This.Com.storeKeyValue() Key is already stored for the application. UndefinedKeyException This.Com.getKeyValue(), App.Com.getKeyValue() Key does not exist."},{"location":"exceptions/#more-details-on-the-exceptions","title":"More details on the exceptions","text":"<p>The most common exception is ConnectionTimeout that can occur in any call to a remote Server object. As the process of the requests to a remote Server object should be quick, a ConnectionTimeout should mean that the network was not fast enough or the remote computer is not accessible any more.</p> <p>However a call to a local Server object may not throw such a ConnectionTimeout exception. That is why a good practice is:</p> <ul> <li>Set a timeout to remote Server objects.</li> <li>Do not set a timeout to local Server objects.</li> </ul> <p>A SynchronizationTimeout exception has a different meaning. It concerns blocking init() calls for the Requester and Subscriber objects. Indeed, a Requester may block indefinitely if the Responder is never ready. In that case, setting a timeout makes the init() call exit.</p> <p>An InitException exception should be thrown if the underlying communication object cannot be initialized i.e. ZeroMQ sockets.</p> <p>An InvalidArgumentException happens when the provided endpoint is invalid e.g. \"tc://serv:10000\" or \"tcp://serv:\".</p> <p>The StartException exception occurs when the CAMEO server is unable to start the requested application. It can happen if the program is not accessible or the maximum number of running apps is reached.</p> <p>The UnregisteredApplicationException exception occurs for an application that is not registered in the CAMEO server and tries to attach to it. If the maximum number of running apps is reached, it cannot attach.</p> <p>The exceptions KeyAlreadyExistsException and UndefinedKeyException are thrown in the communication objects. These exceptions concern the implementation of a communication object e.g. Requester, Responder, etc.</p> <p>Notice that a Requester.receive() call does not throw an exception if a timeout occurs. However the object returned is null and Requester.hasTimedout() returns true.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>We present a complete simple example where two CAMEO applications interact with a publisher/subscriber pattern.</p>"},{"location":"getting-started/#code","title":"Code","text":"<p>We define:</p> <ul> <li>a C++ publisher application that publishes to a single subscriber.</li> <li>a Java subscriber application which starts the publisher application on the local CAMEO server and subscribes to it.</li> </ul> <p>Code for the C++ Publisher application: <pre><code>#include &lt;cameo/api/cameo.h&gt;\n\nint main(int argc, char *argv[]) {\n\n    // Initialise the CAMEO application represented by This. \n    cameo::This::init(argc, argv);\n\n    // Declare a publisher.\n    std::unique_ptr&lt;cameo::coms::Publisher&gt; publisher;\n\n    try {\n        // Create the publisher with name \"pub\" that waits for a single subscriber.\n        publisher = cameo::coms::Publisher::create(\"pub\");\n        publisher-&gt;setWaitForSubscribers(1);\n\n        // Initialize the publisher. Synchronize with the subscriber.\n        publisher-&gt;init();\n\n        // Once here, we are sure that the subscriber is ready\n        // and will be able to receive all the messages.\n    }\n    catch (const cameo::InitException&amp; e) {\n        // The publisher cannot be created.\n        return 1;\n    }\n\n    // Set the state RUNNING.\n    cameo::This::setRunning();\n\n    // We can send data to the unique subscriber.\n    publisher-&gt;send(\"hello\");\n    publisher-&gt;send(\"world\");\n    publisher-&gt;send(\"!\");\n\n    // Send the end of the stream.\n    publisher-&gt;sendEnd();\n\n    return 0;\n}\n</code></pre> Code for the Java Subscriber application: <pre><code>import eu.ill.cameo.base.App;\nimport eu.ill.cameo.base.Server;\nimport eu.ill.cameo.base.This;\nimport eu.ill.cameo.coms.Subscriber;\n\npublic class SubscriberApplication {\n\n    public static void main(String[] args) {\n\n        // Initialise the CAMEO application represented by This.    \n        This.init(args);\n\n        // Get the local CAMEO server (the one that started This).\n        Server server = This.getServer();\n\n        // Declare the subscriber.      \n        Subscriber subscriber = null;\n\n        try {\n            // Start the publisher application with name \"pubcpp\"\n            // and get a reference to the running application with the Instance object.\n            App publisherApp = server.start(\"pubcpp\");\n\n            // Subscribe to the publisher with name \"pub\".\n            Subscriber subscriber = Subscriber.create(publisherApp, \"pub\");\n\n            // Initialize the subscriber.\n            subscriber.init();\n\n            // We are ready to receive data.\n            while (true) {\n                // Receive string encoded messages.\n                String data = subscriber.receiveString();\n                if (data != null) {\n                    System.out.println(\"received \" + data);\n                }\n                else {\n                    break;\n                }\n            }\n\n            // Finished to receive the data.\n            // We can wait for the termination of the \"pubcpp\" application.\n            int state = publisherApp.waitFor();\n\n            // At this point, the \"pubcpp\" application is terminated and its terminal state is state.\n        }\n        catch (StartException e) {\n            System.out.println(\"cannot start the publisher application\");\n        }\n        catch (InitException e) {\n            System.out.println(\"cannot initialize the subscriber\");\n        }\n        finally {\n            // Do not forget to terminate the subscriber and This in Java.\n            subscriber.terminate();\n            This.terminate();\n        }\n    }\n}\n</code></pre></p> <p>You can notice the call to start() with the \"pubcpp\" name that is not already defined. It will done in the configuration file. Indeed define the code is not enough to run CAMEO applications. We need to configure a CAMEO server.</p>"},{"location":"getting-started/#configuration","title":"Configuration","text":"<p>Here is a possible configuration file config.xml: <pre><code>&lt;config port=\"7000\"&gt;\n    &lt;applications&gt;\n        &lt;application name=\"pubcpp\" log_directory=\"logs\"&gt;\n            &lt;start executable=\"/path/to/pubcppapp\"/&gt;\n        &lt;/application&gt;\n        &lt;application name=\"subpubjava\" log_directory=\"logs\"&gt;\n            &lt;start executable=\"/usr/bin/java\" args=\"-classpath /path/to/tests.jar test.SubscriberApplication\"/&gt;\n        &lt;/application&gt;  \n    &lt;/applications&gt;\n&lt;/config&gt;\n</code></pre> A CAMEO server configuration file contains:</p> <ul> <li>The base port from which it is accessed i.e. 7000.</li> <li>The list of applications that can be started with their name, executable and other attributes. Each application is a mapping between a name and a command including the executable and the fixed arguments. This configuration file supposes:</li> <li>The jar tests.jar contains the code of the Java application.</li> </ul>"},{"location":"getting-started/#execution","title":"Execution","text":"<p>First we must start the CAMEO server. This can be done directly in a shell:</p> <pre><code>cameo-server config.xml --log-console\n</code></pre> <p>Now we have to execute the subpubjava application as it is the entry point. That can be done by using the CAMEO console on the machine that runs the CAMEO server:</p> <pre><code>cmo exec subpubjava\n</code></pre> <p>If serverhost is the hostname of the machine running the CAMEO server, you can go on another machine and run subpubjava remotely:</p> <pre><code>cmo -e tcp://serverhost:7000 exec subpubjava\n</code></pre> <p>You have the first running example.</p>"},{"location":"implementation/","title":"CAMEO","text":"<p>The first goal of CAMEO is to provide services for starting, stopping, synchronizing distributed applications. CAMEO is an application-oriented middleware. The lifecycle of remote applications can be entirely managed either by the CAMEO console or in an application by using the client API in C++, Java or Python.</p> <p>Once applications are managed by CAMEO, some communication patterns between them can be used: requester/responder, publisher/subscriber, return value at the end of the execution of the application. These patterns are high-level and provide some more synchronization.</p> <p>An application started by CAMEO can terminate with an exception but the remote caller will be notified with an error, so that he will be able to take the decision to restart or not the application.</p>"},{"location":"implementation/#implementation","title":"Implementation","text":"<p>CAMEO was designed taking into account the disadvantages of CORBA. Unlike CORBA which shares data references through a naming service, CAMEO shares application instances. This is a real different approach. Thus the applications have the responsibility to organize the sharing of their data with provided CAMEO patterns for communication or not. </p> <p>Internally, a CAMEO server is written in pure Java so that it only requires a compatible virtual machine for running. That makes it very portable and easy to install. Moreover CAMEO application instances are processes started by the server but they can also be started as standalone processes. We take advantage of the continuous Java improvement in its process API to have a unified way to start and monitor processes on different platforms (Linux, Mac OS X, Windows). </p> <p>To organize the network services, we use the robust and reliable ZeroMQ message queue for which a 100% Java implementation called JeroMQ exists. ZeroMQ is not only an open-source library, it also provides a precise documentation on how to use it in different network contexts. For example we followed the recommendations to implement a real synchronized publisher/subscriber pattern. </p> <p>The main feature of a CAMEO server is to start and stop applications on the local system. For that, a CAMEO server is configured with a list of applications. Each application has a list of attributes so that an application instance can be seen as an enriched system process. We won\u2019t provide all the available attributes here but we can cite:</p> <ul> <li>Name: String identifier used by clients to start an application instance.</li> <li>Executable: The path to the executable.</li> <li>Args: The list of arguments that are always passed to the executable.</li> <li>Multiple: yes or no, no meaning that only a single instance of the application can run.</li> <li>Restart: An application instance is restarted in case of error termination.</li> </ul> <p>Applications have a workflow state shown in the next figure.</p> <p></p> <p>Around the Running state, there are the transitional states Starting, Stopping, Killing, Processing Failure and the terminal states Success, Stopped, Killed, Failure. Once the process of the application is launched, the application has the Starting state. It becomes Running when:</p> <ul> <li>It remains alive for a certain time, defined as an attribute of the application or, </li> <li>The application itself changes its state to Running.</li> </ul> <p>When a client requests the stop of the application, it immediately becomes Stopping until it terminates. At that moment, its state becomes Stopped. Notice that after the crash of an application (segmentation fault in C++ or exception in Java), its state becomes Failure. The state changes are all sent to the clients of the application. </p> <p>The messages that are passed between applications can be of any type. CAMEO provides binary messages as well as string messages so that the programmer can choose the encoding that can be Protocol Buffers or JSON. Theses messages can be used in the different communication contexts:</p> <ul> <li>publisher/subscriber</li> <li>request/response</li> <li>return value</li> </ul> <p>The return value of an application is implemented with a publisher/subscriber so that any connected client application receives the result. We provide a client API for C++, Java and Python.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#install-a-release","title":"Install a release","text":""},{"location":"installation/#from-the-packages","title":"From the packages","text":"<p>Debian packages are provided in the releases page. If you can install them, it is the recommended installation. If you cannot then you have to manually compile the components.</p>"},{"location":"installation/#compile-the-components","title":"Compile the components","text":"<p>Download the latest release:</p> <pre><code>git clone -b r3.0.0 --depth 1 https://github.com/ILLGrenoble/cameo.git\n</code></pre> <p>Then follow the instructions here.</p>"},{"location":"installation/#list-of-the-installed-components","title":"List of the installed components","text":"<p>Depending on your &lt;install&gt; directory you should have:</p> <p>Server: <pre><code>&lt;install&gt;/share/java/cameo/cameo-server-jzmq-&lt;version&gt;-full.jar\n&lt;install&gt;/share/java/cameo/cameo-server-jeromq-&lt;version&gt;-full.jar\n&lt;install&gt;/bin/cameo-rep-proxy\n&lt;install&gt;/bin/cameo-pub-proxy\n&lt;install&gt;/bin/cameo-server\n</code></pre> Console: <pre><code>&lt;install&gt;/share/java/cameo/cameo-console-jzmq-&lt;version&gt;-full.jar\n&lt;install&gt;/share/java/cameo/cameo-console-jeromq-&lt;version&gt;-full.jar\n&lt;install&gt;/bin/cmo\n</code></pre> C++ API: <pre><code>&lt;install&gt;/lib/libcameo-api-cpp.so.&lt;version&gt;\n&lt;install&gt;/lib/libcameo-api-cpp.so\n&lt;install&gt;/include/cameo/api/\n&lt;install&gt;/share/cmake/cameo-api-cpp/\n</code></pre> Python API: <pre><code>&lt;install&gt;/lib/cmake/cameopy/\n&lt;install&gt;/lib/python3/dist-packages/cameopy/__init__.py\n&lt;install&gt;/lib/python3/dist-packages/cameopy/cameopy.cpython-310-x86_64-linux-gnu.so\n</code></pre></p> <p>Debian packages have /usr as install directory. From that point, you should have the scripts cameo-server and cmo accessible from a shell.</p>"},{"location":"installation/#running-a-cameo-server","title":"Running a CAMEO server","text":""},{"location":"installation/#launch-the-server","title":"Launch the server","text":"<p>Once it is compiled, a CAMEO server can be run using the cameo-server script which is running a Java virtual machine. It means that you need at least a Java runtime (&gt;=11) from OpenJDK or Oracle.</p> <p>Now create the simple configuration config.xml:</p> <p><pre><code>&lt;config port=\"7000\"&gt;\n    &lt;applications&gt;\n        &lt;application name=\"ping\" info_arg=\"no\"&gt;\n            &lt;start executable=\"/usr/bin/ping\"/&gt;\n        &lt;/application&gt;\n    &lt;/applications&gt;\n&lt;/config&gt;\n</code></pre> How to write a complete configuration file is shown in a next page. Run the CAMEO server:</p> <pre><code>cameo-server config.xml --log-console\n</code></pre> <p>If you encounter a problem with the 7000 port then change it e.g. 11000.</p>"},{"location":"installation/#execute-commands-using-the-console","title":"Execute commands using the console","text":"<p>You can contact the CAMEO server using the cmo console application. If it is installed:</p> <pre><code>cmo list\n</code></pre> <p>If you changed the port then you must specify it:</p> <pre><code>cmo -p 11000 list\n</code></pre> <p>Or you can set the CAMEO_SERVER environment variable to tcp://localhost:11000. Open a new shell and run to execute the ping app with the localhost argument:</p> <pre><code>cmo exec ping localhost\n</code></pre> <p>The ping lines are streamed and you can stop the app by ctl-C.</p>"},{"location":"installation/#tests","title":"Tests","text":"<p>Once you compiled successfully the different components, you can test them at the Tests page.</p>"},{"location":"installation/#run-the-cameo-server-as-a-service","title":"Run the CAMEO server as a service","text":"<p>It is recommended to run your CAMEO server as a service. </p>"},{"location":"installation/#linux","title":"Linux","text":"<p>On Linux, systemd can be used. We give an example of a user systemd configuration:</p> <pre><code>[Unit]\nDescription=CAMEO Server Service\n\n[Service]\nExecStart=/usr/bin/cameo-server ${HOME}/.cameo/config.xml\nWorkingDirectory=/home/user/cameo\nEnvironment=DISPLAY=:0\n\n[Install]\nWantedBy=default.target\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<p>On windows we successfully used nssm. The firewall may ask you to accept running applications. If this is not the case, check the allowed apps in the firewall settings and in particular the Java program. Follow the Microsoft recommendations.</p> <p>Then register the CAMEO service using nssm. Run in command line: <pre><code>nssm install cameo\n</code></pre> Select the CAMEO server bat file and let the working directory as is. Start the newly installed service by starting services.msc in command line and right-click on the CAMEO service and start.</p>"},{"location":"installation/#jzmq-or-jeromq","title":"JZMQ or JeroMQ ?","text":"<p>By default JZMQ is used because it has better performance. The scripts cameo-server and cmo use JZMQ. However if you prefer to use JeroMQ, the server can be called: <pre><code>java -jar &lt;install directory&gt;/share/java/cameo/cameo-server-jeromq-&lt;version&gt;-full.jar \"$@\"\n</code></pre> The console can also be called: <pre><code>java -jar &lt;install directory&gt;/share/java/cameo/cameo-console-jeromq-&lt;version&gt;-full.jar \"$@\"\n</code></pre> Using one or another ZeroMQ implementation is discussed in the page Dependencies.  </p>"},{"location":"installation/#use-the-apis","title":"Use the APIs","text":""},{"location":"installation/#java","title":"Java","text":"<p>To use the Java API, first add to your Maven POM file the repository: <pre><code>&lt;repository&gt;\n    &lt;id&gt;ill-repo-releases&lt;/id&gt;\n    &lt;url&gt;https://maven.ill.fr/content/repositories/releases&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre></p> <p>Then add the dependency: <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;eu.ill.cameo&lt;/groupId&gt;\n    &lt;artifactId&gt;cameo-api&lt;/artifactId&gt;\n    &lt;version&gt;3.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> By default the JZMQ implementation is used which requires to have the Java ZeroMQ binding installed but if your prefer JeroMQ then add the dependencies: <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;eu.ill.cameo&lt;/groupId&gt;\n    &lt;artifactId&gt;cameo-api&lt;/artifactId&gt;\n    &lt;version&gt;3.0.0&lt;/version&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;eu.ill.cameo&lt;/groupId&gt;\n            &lt;artifactId&gt;cameo-com-jzmq&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;eu.ill.cameo&lt;/groupId&gt;\n    &lt;artifactId&gt;cameo-com-jeromq&lt;/artifactId&gt;\n    &lt;version&gt;0.1.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></p>"},{"location":"installation/#c","title":"C++","text":"<p>If you installed the Debian package or compiled manually and have a correct include path you should be able to include:</p> <pre><code>#include &lt;cameo/api/cameo.h&gt;\n</code></pre>"},{"location":"installation/#python","title":"Python","text":"<p>If you installed the Debian package, it should be available directly or if you compiled manually, you should update the PYTHONPATH variable: <pre><code>$ export PYTHONPATH=&lt;cameo install path&gt;/lib/python3/dist-packages:$PYTHONPATH\n</code></pre> Then you can import in your code: <pre><code>import cameopy\n</code></pre></p>"},{"location":"make-the-apps-communicate/","title":"Make the apps communicate","text":"<p>Controlling the CAMEO apps is already a form of communication between the apps. We show here the common ways to make them communicate by using the communication patterns aka coms and the return value.</p> <p>The following examples will only show string messages however any kind of serialization can be used: binary serialization with Protobuf or ascii serialization with JSON.</p>"},{"location":"make-the-apps-communicate/#function-pattern","title":"Function pattern","text":"<p>First and easiest way to pass data from an app to another is to use the function pattern. When an app terminates it is possible to set a return value that will be published to all the instance references. We can extend the Java application of App2:</p> <pre><code>import eu.ill.cameo.base.This;\n\npublic class JavaApp {\n\n    public static void main(String[] args) {\n\n        // Initialize the CAMEO application represented by This.    \n        This.init(args);\n\n        // Infinite printing loop.\n        int i = 0;\n        while (true) {\n            System.out.println(\"Printing \" + i);\n            try {\n                Thread.sleep(100);\n            }\n            catch (InterruptedException e) {\n            }\n            i++;\n        }\n\n        // Set the string result.\n        This.setResult(\"This is a result\");\n\n        This.terminate();   \n    }\n}\n</code></pre> <p>In C++, we can get the string result: <pre><code>#include &lt;cameo/api/cameo.h&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char *argv[]) {\n\n    // Define the reference to the CAMEO server in B.   \n    std::unique_ptr&lt;cameo::Server&gt; server = cameo::Server::create(\"tcp://B:7000\");\n\n    // Start the application \"App2\" and obtain a reference to the running app.\n    std::unique_ptr&lt;cameo::App&gt; app2 = server.start(\"App2\");\n\n    // Wait for the end of the app and get the terminal state.\n    cameo::state::Value state = app2-&gt;waitFor();\n\n    // Get the result and display it.\n    std::optional&lt;std::string&gt; result = app2-&gt;getResult();\n    if (result.has_value()) {\n        std::cout &lt;&lt; \"Result \" &lt;&lt; result.value() &lt;&lt; std::endl;\n    }\n    else {\n        std::cout &lt;&lt; \"No result\" &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre></p> <p>In Java and Python, you have the getStringResult() method and function to retrieve the string result. If you need to set and get a binary result, use the related setResult() and getResult() methods and functions.</p> <p>Use the return value can be very helpful to use an app as a function. However it is not recommended to use it in those cases:</p> <ul> <li>The execution of the app is very short and it is executed lots of time.</li> <li>The data passed are big.  </li> </ul> <p>Indeed in that case it is better to setup a requester/responder communication to avoid too many creation and destruction of processes and to avoid a network overload.</p>"},{"location":"make-the-apps-communicate/#requesterresponder-pattern","title":"Requester/Responder pattern","text":"<p>If you need to setup a request/response mechanism between different apps then use the provided requester/responder communication pattern.</p> <p>An example of a responder in a C++ application registered as ResApp in the CAMEO server: <pre><code>try {\n    // Create the basic responder with name \"the-responder\".\n    std::unique_ptr&lt;coms::basic::Responder&gt; responder = coms::basic::Responder::create(\"the-responder\");\n\n    // Initialize the responder.\n    responder-&gt;init();\n\n    std::cout &lt;&lt; \"Created responder \" &lt;&lt; *responder &lt;&lt; std::endl;\n\n    // Loop on the requests.\n    while (true) {          \n        // Receive the simple request.\n        std::unique_ptr&lt;coms::basic::Request&gt; request = responder-&gt;receive();\n        if (!request) {\n            std::cout &lt;&lt; \"Responder is canceled\" &lt;&lt; std::endl;\n            break;\n    }\n\n    // Print the request data as string.\n    std::cout &lt;&lt; \"Received request \" &lt;&lt; request-&gt;get() &lt;&lt; std::endl;\n\n    // Reply a string to the requester.\n    request-&gt;reply(\"Done\");\n}\ncatch (const coms::InitException&amp; e) {\n    std::cout &lt;&lt; \"Responder error\" &lt;&lt; std::endl;\n}\n</code></pre> The responder is created with the name \"the-responder\" to identify it. The pre-condition for the creation of the responder is that This must have been initialized. Like the return value, it is possible to get the request as binary data using the get() function or method. It is also possible to reply binary data using the reply() method or function. The requests can also be a two-part message and the second part can be get with the getSecondPart() method or function.</p> <p>Let's see an example of requester in Java: <pre><code>try {\n    // Connect to the app RespApp which hosts a responder.\n    App responderApp = server.connect(\"RespApp\");\n\n    // Create a requester to the responder \"the-responder\".\n    Requester requester = Requester.create(responderApp, \"the-responder\");\n\n    // Initialize the requester.\n    requester.init();\n\n    System.out.println(\"Created requester \" + requester);\n\n    for (int i = 0; i &lt; N; ++i) {\n        // Send a simple message as string.\n        requester.send(\"Message-\" + i);\n\n        // Print the response.\n        System.out.println(\"Response is \" + requester.receiveString());\n    }\n\n    // Terminate the requester.\n    requester.terminate();      \n}\ncatch (InitException e) {\n    System.out.println(\"Requester error:\" + e);\n}\n</code></pre></p> <p>The requester is created by connecting the responder named \"the-responder\" living in the RespApp application. Once connected, the requester can send requests and receive the responses. Here again the pre-condition for the creation of the requester is that This must have been initialized.</p> <p>The same requester in Python: <pre><code>try:\n    responderApp = server.connect(\"RespApp\")\n\n    requester = cameopy.coms.Requester.create(responderApp, \"the-responder\")\n    requester.init()\n\n    print(\"Created requester\", requester)\n\n    for i in range(N):\n        request = \"Message-\" + str(i)\n        requester.send(request)\n        response = requester.receiveString()\n        print(\"Response is\", response)\n\n    requester.terminate()\n\nexcept cameopy.InitException:\n    print(\"Requester error\")\n</code></pre></p> <p>You can notice that no port was provided to define the requester and responder. Only a name was provided. The ports are assigned dynamically internally but the programmer does not have to care about.</p> <p>Be careful, the responder must receive requests in a loop after init() otherwise any requester will block when initializing.</p> <p>Notice that the responder can reply multiple times for the same request. The requester must then have as many receive() calls as the number of replies.</p> <p>Notice that we presented the basic responder which cannot process requests in parallel. A single thread must be used to receive and reply. If you need to process the requests in parallel, then you have to create some multiple responders.</p>"},{"location":"make-the-apps-communicate/#multiple-responders","title":"Multiple responders","text":"<p>To process the requests in parallel, a set of multi responders must be created. They are attached to a responder router. </p> <p>An example of multiple responders in a Java application:</p> <p><pre><code>try {\n    // Create the router.\n    ResponderRouter router = ResponderRouter.create(\"the-responder\");\n    router.init();\n\n    // Create 5 multi responders.\n    for (int i = 0; i &lt; 5; ++i) {\n        Thread thread = new Thread(new Runnable() {\n            public void run() {\n\n                Responder responder = null;\n\n                try {\n                    // Create the multi responder by associating it to the router.\n                    responder = Responder.create(router);\n                    responder.init();\n\n                    // Receive requests.\n                    while (!responder.isCanceled()) {\n                        Request request = responder.receive();\n                        System.out.println(\"Received request \" + request.getString());\n\n                        // Reply.\n                        request.replyString(\"Response\");\n                    }\n\n                    responder.terminate();\n                }\n                catch (InitException e) {\n                }   \n            }\n        });\n\n        thread.start();\n    }\n\n    // Start the router by a blocking call.\n    router.run();\n\n    // Terminate the router once finished.\n    router.terminate();\n}\ncatch (InitException e) {\n}\n</code></pre> Once the router is receiving a request from a requester, it forwards it to a multi responder (round-robin distribution) that can process it in its own thread. It can also reply multiple times. The router run() call is blocking and the router must be canceled to return.</p>"},{"location":"make-the-apps-communicate/#publishersubscriber-pattern","title":"Publisher/Subscriber pattern","text":"<p>Another useful communication pattern is the publish/subscribe pattern. It allows asynchronous messages from one application to other ones. Let's define a Java application PubJava which defines a publisher: <pre><code>try {\n    // Create the publisher with name \"the-publisher\".\n    Publisher publisher = Publisher.create(\"the-publisher\");\n\n    // Set the number of subscribers to wait to 1.\n    publisher.setWaitForSubscribers(1);\n\n    // Synchronize with the subscriber(s). Wait for the subscriber to connect.\n    publisher.init();\n\n    // Send data.\n    for (int i = 0; i &lt; 100; ++i) {\n        publisher.send(\"message \" + i);\n    }\n\n    // Terminate the publisher.\n    publisher.terminate();\n}\ncatch (InitException e) {\n    System.out.println(\"Publisher error:\" + e);\n}\n</code></pre></p> <p>Here again, This must have been initialized before creating the publisher. We provide a synchronization feature with the second argument of the Publisher.create() method: the number of subscribers can be provided. The call to Publisher.init() is blocking until the required number of subscribers has been reached. This allows to have subscribers that will receive all the messages: The publisher is synchronized. Default value is 0 and in that case Publisher.init() immediately returns. Then the publisher is not synchronized and some messages may be lost. There is another option for the publisher: synchronized subscribers. It is set using setSyncSubscribers() instead of setWaitForSubscribers() so that the publisher is not waiting for the subscribers but the subscribers are effectively connected at the end of their init(). The implementation requires an additional thread that is why it is not set by default.</p> <p>Let's give an example of a subscriber in C++: <pre><code>try {\n    // Connect to the app PubApp which hosts a publisher.\n    std::unique_ptr&lt;App&gt; publisherApp = server.connect(\"PubApp\");\n\n    // Create a subscriber to the application.\n    std::unique_ptr&lt;coms::Subscriber&gt; subscriber = coms::Subscriber::create(*publisherApp, \"the-publisher\");\n\n    // Initialize the subscriber.\n    subscriber-&gt;init();\n\n    // Receive data.\n    while (true) {\n        std::optional&lt;std::string&gt; message = subscriber-&gt;receive();\n\n        // If there is no value then the subscriber will not receive messages any more.\n        if (!message.has_value()) {\n            break;\n        }\n        std::cout &lt;&lt; \"Received \" &lt;&lt; message.value() &lt;&lt; std::endl;\n    }\n}\ncatch (const InitException&amp; e) {\n    std::cout &lt;&lt; \"Subscriber cannot be created\" &lt;&lt; std::endl;\n}\n</code></pre> The subscriber is created by connecting to the publisher named \"the-publisher\" living in the PubApp application. Once connected, the subscriber will receive the messages until an empty message arrives. Here again the pre-condition for the creation of the subscriber is that This must have been initialized.</p> <p>The same subscriber in Python: <pre><code>try:\n    # Connect to the app PubApp which hosts a publisher.\n    publisherApp = server.connect(\"PubApp\")\n\n    # Create a subscriber to the application.\n    subscriber = cameopy.coms.Subscriber.create(publisherApp, \"the-publisher\")\n\n    # Initialize the subscriber.\n    subscriber.init()\n\n    # Receive data.\n    while True:\n        message = subscriber.receiveString()\n        if message:\n            print(\"Received\", message)\n        else:\n            break\n\nexcept cameopy.InitException:\n    print(\"Subscriber error\")\n</code></pre></p> <p>As for the requester/responder no port was provided to define the publisher and subscriber. but only a name. Moreover the CAMEO implementation provides a bit of synchronization with the number of subscribers which can be very useful.</p> <p>The communication patterns provided by CAMEO are high-level and allow programmers to rapidly design a communication between apps.</p>"},{"location":"synchronization/","title":"Synchronization","text":"<p>The C++, Java and Python APIs provide a synchronous programming model with some blocking calls. This model provides a simple and easy understandable way of programming.</p>"},{"location":"synchronization/#blocking-calls","title":"Blocking calls","text":""},{"location":"synchronization/#list-of-blocking-functions-or-methods","title":"List of blocking functions or methods","text":"<p>Here is the list of blocking functions or methods:</p> Class Function/Method Feature Server init() Timeoutable App waitFor() Cancelable Publisher init() Cancelable Subscriber init() Cancelable, timeoutable Subscriber receive() Cancelable Responder receive() Cancelable Requester init() Cancelable, timeoutable Requester receive() Cancelable, timeoutable <p>The cancelable functions or methods are canceled by calling cancel(). When a timeout occurs, the call terminates with an exception.</p>"},{"location":"synchronization/#cancel-the-blocking-calls","title":"Cancel the blocking calls","text":"<p>A blocking call blocks the thread in which it executes. To unblock it, the cancel call must be done in another thread. For example in C++ supposing we have a server object: <pre><code>// Use a shared_ptr to use it in the thread and the main thread.\nstd::shared_ptr&lt;cameo::App&gt; app(server.start(\"App\"));\n\n// Start the cancel thread.\nstd::thread cancelThread([&amp;] {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    app-&gt;cancel();\n});\n\n// Wait for the app that will be canceled if it does not return within 1 s.\napp-&gt;waitFor();\n\n// Join the thread.\ncancelThread.join();\n</code></pre></p> <p>Same mechanism can be done for a Responder in Java: <pre><code>// Create a responder.\nfinal Responder responder = Responder.create(\"the-responder\");\n\n// Create and start the cancel thread.\nThread cancelThread = new Thread(() -&gt; {\n    try {\n        Thread.sleep(1000);\n        responder.cancel(); \n    }\n    catch (InterruptedException e) {\n    }\n});\ncancelThread.start();\n\n// Blocking call.       \nRequest request = responder.receive();\n\n// Check request.       \nif (request == null) {\n    System.out.println(\"Responder has been canceled\");      \n}\n\n// Join the thread.     \ncancel.join();\n</code></pre> Each blocking call can be unblocked with a specific function or method, however it is also possible to do it with a central call which unblocks every blocking call: use the cancelAll() function or method of This. Its purpose is mainly to unblock all the blocking calls when a stop handler is triggered to properly close the application. For example in Python supposing we have a server object: <pre><code># Function for the thread.\ndef cancelAll():\n    time.sleep(1)\n    cameopy.This.cancelAll()\n\n# Start the app.\napp = server.start(\"App\")\n\n# Start the cancel thread.\ncancelThread = threading.Thread(target=cancelAll)\ncancelThread.start()\n\n# Wait for the app that will be canceled if it does not return within 1 s.\napp.waitFor()\n\n# Join the thread.    \ncancelThread.join()    \n</code></pre> Once again we need another thread to unblock the call to waitFor().</p> <p>You noticed that the create() functions or methods of the Requester and Subscriber classes were not yet cancelable. Indeed they are blocking calls - we will see later why it is interesting - but the current implementation does not allow to cancel them. However a future release will allow to do it.</p>"},{"location":"synchronization/#timeout","title":"Timeout","text":"<p>Some functions or methods are timeoutable e.g. init() in Server and receive() in Requester. For the server in C++: <pre><code>// Create the server object.\nunique_ptr&lt;Server&gt; server = Server::create(\"tcp://localhost:11000\");\n\n// Set the connection timeout.\nserver-&gt;setTimeout(1000);\n\n// Initialize the server. An exception may be thrown.\nserver-&gt;init();\n</code></pre> If the connection cannot be established within 1000 ms, an exception is thrown in init().</p> <p>For the requester in C++: <pre><code>// Send a request.\nrequester-&gt;send(\"request\");\n\n// Set the response timeout.\nrequester-&gt;setTimeout(2000);\n\n// Receive the response.\noptional&lt;string&gt; response = requester-&gt;receive();\n\n// Check timeout.\nif (requester-&gt;hasTimedOut()) {\n  // The responder did not respond within 2 s.\n}\n</code></pre> Here this the time to let the responder to send a response i.e. the connection can still be established but simply the responder takes too much time to respond.</p>"},{"location":"synchronization/#the-benefits-of-synchronization","title":"The benefits of synchronization","text":"<p>We saw that the init() functions or methods of the Requester and Subscriber were blocking. It means that they do not return until they effectively connected. For the requester it means that it waits for the responder to be initialized. For the subscriber it means that it waits for the publisher to be initialized. This feature is important as it allows to start an application - operation that is asynchronous - and define a requester/responder pair that themselves are synchronized. This allows you to define chains of applications like it is shown in this figure:</p> <p></p> <p>The application App2 is executed in parallel with App1 however the responder and requester creations are synchronized and it is ensured that no request will be lost. In the same way, App3 is executed in parallel with App2, subscriber and publisher creations are synchronized - if the publisher is synchronized of course - so that no published message is lost.</p> <p>Another synchronization possibility is to use the RUNNING state. An application can itself declare RUNNING. For example in C++, the beginning code of CppApp: <pre><code>int main(int argc, char *argv[]) {\n\n    // Initialize the app.\n    cameo::This::init(argc, argv);\n\n    // Sleep for 1 s.\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n\n    // Set the state RUNNING.\n    cameo::This::setRunning();\n</code></pre></p> <p>The application that starts CppApp in Python: <pre><code># Start the app.\napp = server.start(\"CppApp\")\n\n# Wait for the state RUNNING.\napp.waitFor(cameopy.state.RUNNING)\n</code></pre></p> <p>The call to waitFor() will wait until the state RUNNING is published by the CAMEO server of CppApp.</p> <p>CAMEO offers a very easy way to synchronize the apps, opening the possibility of building chains of synchronized applications of which lifecycle is managed properly.</p>"},{"location":"tests/","title":"Tests","text":""},{"location":"tests/#setup","title":"Setup","text":""},{"location":"tests/#linux","title":"Linux","text":"<p>The Java, C++ and Python tests can be run using either jzmq or jeromq.</p> <p>Open a shell and go to the root CAMEO directory:</p> <p>Set the PATH variable so that the C++ programs are found: <pre><code>export PATH=build/tests/cpp:build/cpp/proxy:$PATH\n</code></pre></p> <p>If necessary, set the PYTHONPATH variable so that the cameopy module is found e.g.: <pre><code>export PYTHONPATH=/path/to/install/lib/python3/dist-packages:$PYTHONPATH\n</code></pre> You may have to verify that python is defined (install python-is-python3 package on Ubuntu).</p> <p>Select jzmq or jeromq Java library.</p> <p>Case jzmq: <pre><code>export CLASSPATH=tests/java/jzmq/target/cameo-tests-jzmq-full.jar\n</code></pre></p> <p>You shall define the variable LD_LIBRARY_PATH so that libjzmq.so is found: <pre><code>export LD_LIBRARY_PATH=/path/to/libjzmq\n</code></pre></p> <p>Case jeromq: <pre><code>export CLASSPATH=tests/java/jeromq/target/cameo-tests-jeromq-full.jar\n</code></pre></p>"},{"location":"tests/#windows","title":"Windows","text":"<p>Open a standard prompt and go to the CAMEO root directory. Then set the PATH: <pre><code>set PATH=build\\examples\\cpp\\Release;build\\cpp\\proxy\\Release;%PATH%\n</code></pre></p> <p>Set the CLASSPATH to use jeromq: <pre><code>set CLASSPATH=tests\\java\\jeromq\\target\\cameo-tests-jeromq-full.jar\n</code></pre></p> <p>If necessary, set the PYTHONPATH variable so that the cameopy module is found e.g.: <pre><code>set PYTHONPATH=build\\python\\api\\Release;%PYTHONPATH%\n</code></pre></p>"},{"location":"tests/#run-the-tests","title":"Run the tests","text":"<p>Run all the tests with 10 iterations for each individual test: <pre><code>java eu.ill.cameo.test.TestSelector all 10\n</code></pre> Start only the java tests: <pre><code>java eu.ill.cameo.test.TestSelector java 10\n</code></pre> Start only the C++ tests: <pre><code>java eu.ill.cameo.test.TestSelector cpp 10\n</code></pre> Start only the Python tests: <pre><code>java eu.ill.cameo.test.TestSelector python 10\n</code></pre> Display the available tests: <pre><code>java eu.ill.cameo.test.TestSelector\n</code></pre></p> <p>Start a specific test: <pre><code>java eu.ill.cameo.test.TestSelector testsimplejava 100\n</code></pre></p> <p>Test the Java unmanaged application: Start the server in a specific shell <pre><code>java eu.ill.cameo.server.Server tests/java/tests.xml\n</code></pre> Start the application: <pre><code>java eu.ill.cameo.test.Stop \"{\\\"name\\\":\\\"stop\\\", \\\"server\\\":\\\"tcp://localhost:11000\\\"}\"\n</code></pre></p> <p>Then kill the application that should disappear from the list of applications.</p> <p>Test the C++ unmanaged application <pre><code>stop \"{\\\"name\\\":\\\"stop\\\", \\\"server\\\":\\\"tcp://localhost:11000\\\"}\"\n</code></pre></p>"},{"location":"track-the-app-failures/","title":"Track the app failures","text":"<p>In CAMEO, an app that crashes is not an unexpected behavior but is a common use case. However how to track the failures? How to interrupt a communication with an app responder or publisher if the app has crashed?</p>"},{"location":"track-the-app-failures/#control-the-state","title":"Control the state","text":"<p>We already saw the different ways of getting the state of an app in a previous section. To track the failure it is possible to poll using getLastState(). In Java:</p> <p><pre><code>// Get an app.\nApp app = server.connect(\"App2\");\n\n// Infinite loop.\nwhile (true) {\n    if (app.getLastState() == State.FAILURE) {\n        System.out.println(\"Application \" + app.getName() + \" failed!\");\n        break;\n    }\n    else if (app.getLastState() == State.SUCCESS) {\n        System.out.println(\"Application \" + app.getName() + \" finished successfully\");\n        break;\n    }\n    else if (app.getLastState() == State.STOPPED || app.getLastState() == State.KILLED) {\n        System.out.println(\"Application \" + app.getName() + \" has been terminated\");\n        break;\n    }\n}\n</code></pre> Using getLastState(), the app can have crashed a long time ago but the app object will still return the last state of the running program.</p> <p>You can also wait for the termination of the app and in that case you will get the terminal state. In Python: <pre><code># Get an app.\napp = server.connect(\"App2\")\n\n# Wait for its termination.\nstate = app.waitFor()\n\n# Check the state.\nif state == cameopy.state.FAILURE:\n    print(\"Application\", app.getName(), \"terminated with failure\")\n</code></pre></p> <p>Using waitFor() you will get the notification of the failure as soon as it happens however it is a blocking call so that you will have to put it in a thread to control the code. That is the strategy of the check app feature of the coms classes shown in the next section.</p>"},{"location":"track-the-app-failures/#failure-of-a-responder-app","title":"Failure of a Responder app","text":"<p>Suppose you defined a Requester and connected it to a Responder defined on a remote app. What happens if the remote app is crashing? A timeout can be set for a Requester so that the receive() call will return if the remote app has crashed and is unable to respond. However it is possible to not set a timeout and the Requester shall wait indefinitely in the receive() call. To avoid the blocking, you can define the Requester with the check app feature enabled. In Java:</p> <p><pre><code>// Connect to the app RespApp which hosts a responder.\nApp responderApp = server.connect(\"RespApp\");\n\n// Create a requester to the responder \"the-responder\" with the check app feature enabled.\nRequester requester = Requester.create(responderApp, \"the-responder\");\nrequester.setCheckApp(true);\n\n// Initialize the requester.\nrequester.init();\n\n// Send requests.\nwhile (true) {\n    // Send a simple message as string.\n    requester.send(\"Message\");\n\n    // Print the response.\n    byte[] response = requester.receive();\n\n    // Check the response.\n    if (response == null) {\n        int lastState = responderApp.getLastState();\n        if (lastState == State.FAILURE) {\n            System.out.println(\"Responder app terminated with state FAILURE\");\n            break;\n        }\n    }\n}\n\n// Terminate the requester.\nrequester.terminate();      \n</code></pre> We check the response from receive() which is null only if the Requester is canceled. If the Responder app is crashing then the Requester is automatically canceled and the receive() call returns. Notice that the check app feature requires an additional thread for the Requester.</p>"},{"location":"track-the-app-failures/#failure-of-a-publisher-app","title":"Failure of a Publisher app","text":"<p>Suppose you defined a Subscriber and connected it to a Publisher defined on a remote app. What happens if the remote app is crashing? If the remote app has crashed the Subscriber will wait indefinitely in the receive() call. To avoid the blocking, you can define the Subscriber with the check app feature enabled. In C++: <pre><code>// Connect the app PubApp.\nstd::unique_ptr&lt;App&gt; publisherApp = server-&gt;connect(\"PubApp\");\n\n// Create a subscriber with the feature check app enabled.\nstd::unique_ptr&lt;coms::Subscriber&gt; subscriber = coms::Subscriber::create(*publisherApp, \"publisher\");\nsubscriber-&gt;setCheckApp(true);\n\n// Initialize the subscriber.\nsubscriber-&gt;init();\n\n// Receive data.\nwhile (true) {\n    std::optional&lt;string&gt; data = subscriber-&gt;receive();\n\n    // Check the data, exit the loop if there is no data.\n    if (!data.has_value()) {\n        break;\n    }\n}\n\n// The publication is finished.\nState state = publisherApp-&gt;waitFor();\nif (state == state::FAILURE) {\n    std::cout &lt;&lt; \"Publisher application terminated with state FAILURE\" &lt;&lt; std::endl;\n}\n</code></pre></p> <p>We check the response from receive() which is null only if the publication is terminated. If the Publisher app has crashed then the receive() call returns and we can check the state of the app.</p>"},{"location":"use-the-proxies-with-a-firewall/","title":"Use the proxies with a firewall","text":"<p>In the context of a firewall, you may run the CAMEO server with proxies so that the number of exposed ports is fixed.</p>"},{"location":"use-the-proxies-with-a-firewall/#open-ports","title":"Open ports","text":"<p>CAMEO communication is based on ZeroMQ for which main sockets own a port. For instance you open a REP or a PUB socket by opening a new port. CAMEO communication objects Responder and Publisher have between one and two ports opened dynamically. Moreover the CAMEO server itself opens some ports. As a consequence, the number of ports used by a CAMEO application can increase rapidly.  </p> <p>The following diagram is showing two apps communicating with some Requester/Responder and Publisher/Subscriber objects:</p> <p></p> <p>There is at least five open ports that must be accessible from the computer B. Moreover as they are dynamically opened, they may not always have the same value. In the context of a firewall which needs to minimize the number of ports accessible from outside, this is not suitable.</p> <p>The solution is to use proxies.</p>"},{"location":"use-the-proxies-with-a-firewall/#use-of-proxies","title":"Use of proxies","text":"<p>Using proxies allows to forward messages. There is a responder proxy which is a relay between the Requester and the Responder objects. There is also a publisher proxy which is a relay between the Subscriber and the Publisher objects.</p> <p>The proxies are launched by the CAMEO server. You simply have to specify which ports they will use. For instance you can specify in the configuration file: <pre><code>proxy_ports=\"10000, 10001, 10002\"\n</code></pre> The first port 10000 is the port of the responder proxy. The second port 10001 is the port of the publisher proxy. The third port is for internal use.</p> <p>The following diagram is now showing the same apps with the responder and publisher proxies configured on the computer A:</p> <p></p> <p>The applications on computer B access the responders and publishers through the proxies. However passing through the proxies is not automatically done. It must be specified at the creation of the CAMEO server object referencing the server of the computer A.</p> <p>If you were not using the proxies, the creation would have been in C++ for App3: <pre><code>auto server = cameo::Server::create(\"tcp://A:7000\");\n</code></pre> The port is the base port of the CAMEO server.</p> <p>However the C++ creation of the CAMEO server with proxies: <pre><code>auto server = cameo::Server::create(\"tcp://A:10000\", cameo::option::USE_PROXY);\n</code></pre> In Java: <pre><code>Server server = Server.create(\"tcp://A:10000\", Option.USE_PROXY);\n</code></pre></p> <p>The first argument of Server::create() is the responder proxy endpoint and the second argument is the integer telling that this is the proxy port.</p> <p>Once the server is created, the definition of a Requester or Subscriber is exactly the same as before.</p>"},{"location":"use-the-proxies-with-a-firewall/#proxy-path","title":"Proxy path","text":"<p>Currently, the proxy programs are written in C++. When the CAMEO server starts, it tries to launch the proxy programs. However if they are not installed in a standard path, they may not be found. In that case, an argument is provided:</p> <pre><code>java -jar java/server/target/cameo-server-2.0.0-full.jar --proxy-path /my/path/to/proxies\n</code></pre>"},{"location":"use-the-proxies-with-a-firewall/#list-of-functions-or-methods-using-the-proxies","title":"List of functions or methods using the proxies","text":"<p>Here is the list of functions or methods that can be parameterized with a proxy:</p> Class Function/Method Server create() This connectToStarter() basic::Request connectToRequester() multi::Request connectToRequester() <p>If the a server has been created with a proxy then the App objects that it returns will also use the proxy.</p> <p>Notice that it is possible that each computer has a CAMEO proxy and two remote apps use them to communicate. Look at the following example:</p> <p></p> <p>App2 on the computer B is connecting to App1 on computer A. For that the CAMEO server representing A on B is created with a proxy. A message is sent to the proxy of A that forwards it to the CAMEO server.</p> <p>Then App2 requests App1 using the proxy automatically. This time when App1 receives a request it connects to the requester. For that it is using the proxy meaning that it sends a message to the proxy of B that is forwarded to App2.</p>"},{"location":"versions-and-releases/","title":"Versions and releases","text":""},{"location":"versions-and-releases/#versioning","title":"Versioning","text":"<p>The cameo project contains five main projects Server, Console, Java API, C++ API, Python API that have their own version but are dependent.</p> <p>Here are the rules for the definition of the version of a project among Server, Console, Java API, C++ API, Python API:</p> <ul> <li> <p>Major: Incremented for all the projects. A new value means that the server is not compatible with a client with a smaller major version.</p> </li> <li> <p>Minor: If a project among the five has a new functionality, its new minor value is the maximum of the current five minor values plus one. The Python API minor value must be the same as C++ API and the binding should be updated when the C++ API is updated. If the same functionality is implemented in Server, C++ API, Java API, they can all have the same new minor value.</p> </li> </ul> <p>E.g. the new version of Java API with current versions Server = 1.3.1, Console = 1.2.0, Java API = 1.3.3, C++ API = 1.4.1 is 1.5.0.  </p> <ul> <li>Revision: Each project has its own revision value that is incremented when a bug fix or an optimization is done.</li> </ul> <p>When we need to tag the global cameo project:</p> <ul> <li>Major: Same as the five projects.</li> <li>Minor: Maximum of the current five minor values.</li> <li>Revision: Its own revision value that is incremented when a new tag is made with existing major and minor values.</li> </ul>"},{"location":"versions-and-releases/#new-release","title":"New release","text":"<p>When making a new release, follow the steps:</p> <ul> <li>Check the package versions in the CMakeLists.txt files of the different five projects. The version of the CAMEO project at the root is not used but should follow the global tag rule.</li> <li>Tag the global project. Add release notes so that gitlab considers it is a release.</li> <li>Generate the deb packages using build_and_package.sh.</li> <li>Add the packages in the releases directory of the wiki sources of CAMEO.</li> <li>Add the packages as assets in the gitlab edit release page of the version.   E.g. for the version 1.1.0, the base link is https://code.ill.fr/cameo/cameo/-/wikis/releases/1.1.0/.</li> </ul>"},{"location":"versions-and-releases/#develop-on-a-branch","title":"Develop on a branch","text":"<p>Sometimes we need to develop two branches on the same machine. Developing an alternative version can be done. Download the alternative version: <pre><code>git clone https://code.ill.fr/cameo/cameo.git --branch v1\n</code></pre> Compile the Java sources: <pre><code>cd cameo\nmvn clean install\n</code></pre> Access the server full jar: <pre><code>cameo-server-jzmq/target/cameo-server-jzmq-1.0.0-full.jar\n</code></pre> Access the console full jar: <pre><code>cameo-console-jzmq/target/cameo-console-jzmq-1.0.0-full.jar\n</code></pre></p> <p>Compile and install the C++ API sources into a temporary directory e.g. /tmp/cameo-install : <pre><code>cd cameo-api-cpp\nmkdir build\ncd build\ncmake -DCMAKE_INSTALL_PREFIX=/tmp/cameo-install ..\ncmake --build . --target install\n</code></pre> Access the include and .so files from the temporary directory.</p>"}]}