New features:
+ add the PROGRESSION stream messages (optional)
	set a minimum frequency to avoid resource leaks
	new port?
+ GUI for the administration of the server
	+ JavaFX
	+ add applications
+ add/remove applications to the server programmatically
+ rendezvous
+ publisher/subscriber 
	non-synchronized publisher/subscriber
	How to ensure a susbcriber is synchronized? if it first connects and get the current state?
		with events that are a sub-part of the structure?
			date the events?
			also requires that the subscriber is ready to receive events
			a publisher thread is required
		pattern to have data structure completely synchronized with partial update events (as opposed to non-partial)
		status values can be ordered, so that having the last value is easy : the biggest value
	dead publisher application
		clarify with documentation : Subscriber.hasEnded() returns false
	+ in case non-sync, define a thread that runs Publisher.waitFor 
		change while test
		add an inproc socket
	so that the Publisher knows when the subscriber is really ready to receive
+ timeout on Subscriber and Requester creation
	can be 0, in that case, it does not wait
+ unification multi-method
	Application records handler for different kind of messages (stop, requests, subscriber, etc.) all can be managed with a multi-method and async programming
	Necessity to have "accusÃ© de reception" for the answer
+ add start(..., boolean linkExecution = true)
	if linkExecution, then the child application stops after the main application dies
+ python client API
+ deployment
	send binary content for update
		or an archive that is open => replaces the installation dir : define a <deploy>
	versioning of application : optional value
+ a cameo server R can be a router
	a server R records another server S : in configuration file of S
	start "app" : is dispatched to the most available server
	connect "app" : returns the instance of the most available server
	provide the list of available servers
+ add This.getInstance
	generalize use of signals: handleStop recorded as handler for a state change

Improvements:
+ process priority?
+ check timeout strategy
	ideas
		for a blocking call like waitFor, periodical tests must be provided
		zeromq reliability: http://zguide.zeromq.org/php:chapter4
		failure example: remote app starts but a network failure happens before the setResult
		the change of state is ok but not the starter blocks on getResult (recv call)
+ can we check the availability of a port? reserve some ports?
	procedure to add/reserve ports
	reserve a pool of ports? limit its number?
	accept multiple=yes with show stream?
+ Maven configuration to be implemented
	manage versions
+ C++11
	replace auto_ptr by unique_ptr	
	noncopyable
	C headers to be replaced: stdint.h, etc.
+ possibility to change the type of socket?
	Wrapper interface?
+ study how the project is related to others
	asynchronous API => future/promise model, how it is not enough
	some equivalent or not?
+ thread safety
	clarify documentation
+ when too many data are sent by a publisher, the receiver can wait for a long time
	do fine tests to understand the cycles
	high watermark? configurable?
+ optimise data transfer with Xavier code
+ study Erlang 
	https://en.wikipedia.org/wiki/Erlang_(programming_language)
+ publisher ports
	they are variable, depending on application sessions
	we can add a flag to <application>
		<publisher name=""/>
	reserves fixed ports in case the application is single instance
	allows that the publisher application can die and restart with the same publisher without having to manage it by the subscriber application 
+ optimize the status publication
	one bind per application (same port) but synchronization must be ensured (subscriber really subscribed).
+ improve the error messages
	should always be set when ERROR state occurs
+ change implementation of the communication client/server with JSON (more portable than protobuf)
	look at string encoding: UTF8? with ZeroMQ?
+ implement toString methods with JSON format
+ refactor use of ZeroMQ
	gather code
	manage exceptions from ZeroMQ
		list (ex: invalid host generates an exception)
	could be interesting for implementation of non-synchronized subscribers
+ refactor definition of communication classes
	Publisher and Subscribers implemented outside Application (com package)
	extract services from Application (and Impl) required to implement as external (the idea is to have an example of how to create a communication service)
	=> enable communication extensibility
	change create method to builder?
	
Minor updates:
+ if the host is not available, zmq throws an exception (ex: muttiport shutdown), catch it (everywhere a socket is open?).
+ request version of the server
+ test outputStreamSocket null
	can occur when connecting to application and it dies before
+ test performance
	 maximum speed, no logs (configure the level written in config.xml)
+ test document
+ JeroMQ recvStr issue
	https://github.com/zeromq/jzmq/issues/286
+ implement multiple stream for multiple applications
	STREAM.3 to indicate id 3
+ distinguish error stream from output stream?
	imposes to have a different thread to manage error inputs
	we should wait to have a different way to do it?
+ add log to Application and Server in local applications?
+ check kill can be done at any time (e.g. during stopping)	
+ console : CTL-C 1 = stopping, CTL-C 2 = killing
+ check the attributes that are defined by default in config (ex: stop_command)
+ warning
	with remote calls that change the state of an application, ex: waitForStop
	what happens if waitForStop occurs between hasToBeKilled and other subsequent calls 
+ how to debug a Java application, C++ application
	Java : add an application with debug parameters
	C++ : gdb attach : need that Console displays the PID => PID ---| state ---| name ---| parameters
+ have "inf" (= -1) value for number of applications
+ test with application taking 100% processor, can it be killed easily?
+ monitor: test the real disconnection of a server (without dying) and the reconnection	
+ C++ Server: default constructor with Application::getEndpoint()
+ if application fails immediately and starting_time = 0, there is no output and the console blocks in test mode
+ test of waitFor in getResult()
	what to if ERROR
	no only if Result event arrived
+ sync NomadServer in NomadCommandSystem
	connect then test to know if is terminating
+ remove StateException becomes runtime exception
+ stop handler
	change the stopping time to avoid to define stopping time = 0
	0 = kill, -1 (inf) = no stop
+ stopping_time=0 has a side-effect
	the application terminates successfully even if it fails (e.g. segmentation fault)
+ test incompatible versions of cameo java : is the server okay if parsing fails?
	example : server in different version than client
+ daemon on MacOS
	https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html
	we can explain that cameo is like a unified daemon manager
+ review application::This::Scope app(argc, argv); // object built
+ setResult(void *, size), setBinaryResult(string) in C++
	complete the API
+ manage errors
	replies must take them into account (ex: RequesterImpl)
	protobuf errors, etc.
+ implement Responder.connectToRequester()
	returns an Instance object
+ initialState to be removed and replaced with getPastStates
	requires to have a synchronized access to pastStates (check thread safety)
+ deployment
	simple solution
		push a new version on a server
		the server installs it when the application stops (option: stop the app immediately)
		the application has the state UPGRADING 
		only an update is waiting (replaced if a new version is requested)
			the config file is modified after each installation
			the server shall not be brutally stopped
			enable to stop nicely the server
		states: UP_TO_DATE, WAITING_FOR_UPDATE (version is waiting to be installed), UPDATING, ERROR (block the app?)
		default installation: copy file (jar) to install_directory, untar a tar to install_directory
		or an installation script
		command line: cameo app1 update app1.jar 1.2.3
	monitoring
    	notifications: status VERSION value
    	version in the application info
	interaction with execution
		update when state is inactive
     	do not push the start request if the app is UPDATING (the queue will be implemented later) 
	This can access version

 	